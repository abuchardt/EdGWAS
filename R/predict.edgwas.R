#' Extract coefficients from a edgwas object
#'
#' Similar to other predict methods, this function predicts fitted values and extract coefficients from a fitted "edgwas" object.
#'
#' @param object Fitted "edgwas" object.
#' @param rho Value(s) of the penalty parameter rho at which predictions are required. Default (NULL) is the entire sequence used to create the model.
#' @param newPS Matrix of new values for x of dimension nobs x nouts (must be polygenic scores - can be generated by \code{\link{ps.edgwas}}) at which predictions are to be made. This argument is not used for \code{type = "coefficients"}.
#' @param type Type of prediction required. Type "link" returns a list of length nouts of matrices of dimension nobs x length(rho) of the fitted values for each response. Type "coefficients" gives the coefficients at the requested values for rho.
#'
#' @return The object returned depends on type.
#'
#' @examples
#'
#' N <- 1000
#' q <- 10
#' p <- 100
#' set.seed(1)
#' x <- matrix(sample(0:2, N*p, replace=TRUE), nrow=N, ncol=p)
#' B <- matrix(0, nrow = p, ncol = q)
#' B[1, 1:2] <- 5
#' y <- x %*% B + matrix(rnorm(N*q), nrow = N, ncol = q)
#' ###
#' pc <- edgwas(x[-(1:100), ], y[-(1:100), ], scores = FALSE)
#' ps <- ps.edgwas(x[1:100, ], y[1:100, ])$PS
#' newy <- predict(pc, newPS = ps)
#'
#' @export predict.edgwas
#'
predict.edgwas <- function(object, newPS, rho = NULL,
                           type = c("link", "coefficients") #"response","nonzero","class"),
                           #exact = FALSE, newoffset,
                           ){
  type <- match.arg(type)
  if (missing(newPS)){
    if (!match(type, "coefficients", FALSE))
      stop("Value for 'newPS' missing")
  }

  if (is.null(rho)){
    rho <- object$rho
  } else if (is.numeric(rho)) {
    if (!rho %in% object$rho)
      stop("rho needs to be a value used to create the model")
  } else stop("Invalid form for rho")

  nrho <- length(rho)

  which <- match(rho, object$rho, FALSE)

  alpha <- object$alpha
  nouts <- nrow(alpha)

  ncoef <- lapply(seq(nouts), FUN = function(l) {
    out <- rbind(alpha[l, which], object$beta[l, which])
    colnames(out) <- paste0("rho", seq(nrho))
    rownames(out) <- c("alpha", "beta")
    out
  })
  names(ncoef) <- paste0("y", seq(nouts))

  if (type == "coefficients")
    return(ncoef)

  # Rotate PSs
  wList <- lapply(object$P, expm::sqrtm) ## nrho x qxq
  psList <- lapply(seq(nrho), FUN = function(X) newPS %*% wList[[X]])

  nfit <- vector(mode = "list", length = nouts)
  nfit <- lapply(nfit, FUN = function(l) matrix(NA, nrow(newPS), nrho))
  for (l in seq(nouts)) {
    psUp <- matrix(NA, nrow(newPS), nrho)
    for(j in seq(nrho)) {
      # Update PSs
      Sigma12 <- object$Sigma[[j]][l, -l, drop = FALSE] # 1 x (q-1)
      Sigma21 <- object$Sigma[[j]][-l, l, drop = FALSE] # (q-1) x 1
      Sigma22I <- solve(object$Sigma[[j]][-l,-l]) # (q-1) x (q-1)#
      psUp <- drop(Sigma12 %*% tcrossprod(Sigma22I, psList[[j]][, -l])) + psList[[j]][, l]
      # Predict
      nfit[[l]][, j] <- cbind(1, psUp) %*% ncoef[[l]][, j]
    }
  }

  nfit
}
