#' Cross-validation for edgwas
#'
#' Does k-fold cross-validation for edgwas, produces multiple plots, and returns a value for rho.
#'
#' @param x Input matrix, of dimension nobs x nvars; each row is an observation vector. A matrix of polygenic scores (PSs) with nvars = nouts. Can be in sparse matrix format.
#' @param y Quantitative response matrix, of dimension nobs x nouts.
#' @param rho (Non-negative) optional user-supplied rho sequence; default is \code{NULL}, and EdGwas chooses its own sequence.
#' @param nfolds Number of folds - default is 10. Although nfolds can be as large as the sample size (leave-one-out CV), it is not recommended for large datasets. Smallest value allowable is \code{nfolds = 3}.
#' @param type.measure Loss to use for cross-validation. Currently two options; the default is \code{type.measure="mse"}, which uses the mean-squared error. \code{type.measure = "mae"} gives the mean absolute error.
#' @param nrho The number of rho values. Default is 40.
#' @param logrho Logical flag for log transformation of the rho sequence. Default is \code{logrho = FALSE}.
#' @param rho.min.ratio Smallest value for rho, as a fraction of rho.max, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero) - default is 10e-04.
#'
#' @details The function runs edgwas nfolds+1 times; the first to get the rho sequence, and then the remainder to compute the fit with each of the folds omitted. The error is accumulated, and the average error and standard deviation over the folds is computed. Note that the results of cv.edgwas are random, since the folds are selected at random. Users can reduce this randomness by running cv.edgwas many times, and averaging the error curves.
#'
#' @return An object of class "cv.edgwas" is returned, which is a list with results of the cross-validation fit. \item{rho}{The values of rho used in the fits.} \item{cvm}{The mean cross-validated error - a vector of length length(rho).} \item{cvsd}{ The estimate of the standard error of cvm.} \item{cvup}{Upper curve = cvm + cvsd.} \item{cvlo}{Lower curve = cvm - cvsd.} \item{name}{A text string indicating type of measure (for plotting purposes).} \item{rho.min}{Value of rho that gives minimum cvm.} \item{rho.1se}{Smallest value of lambda such that the error is within 1 standard error of the minimum.} \item{edgwas.fit}{A fitted edgwas object for the full data.}
#'
#' @examples
#' N <- 1000 #
#' q <- 10 #
#' p <- 1000 #
#' set.seed(1)
#' # Sample 1
#' X0 <- matrix(rbinom(n = N*p, size = 2, prob = 0.3), nrow=N, ncol=p)
#' B <- matrix(0, nrow = p, ncol = q)
#' B[1, 1:2] <- 3
#' y0 <- X0 %*% B + matrix(rnorm(N*q), nrow = N, ncol = q)
#' #y0 <- apply(y0, 2, scale)
#' beta <- ps.edgwas(X0, y0)$beta
#' # Sample 2
#' X <- matrix(rbinom(n = N*p, size = 2, prob = 0.3), nrow=N, ncol=p)
#' y <- X %*% B + matrix(rnorm(N*q), nrow = N, ncol = q)
#' #y <- apply(y, 2, scale)
#' #Sigma <- diag(1, q)
#' #Sigma[1, 2] <- Sigma[2, 1] <- .8
#' #y <- X %*% B + MASS::mvrnorm(n = N, mu = rep(0, q), Sigma = Sigma)
#' x <- X %*% beta
#' #x <- MASS::mvrnorm(n = N, mu = rep(0, q), Sigma = diag(1, q))
#' ###
#' pc <- cv.edgwas(x, y, model = "fgls", logrho = FALSE)
#' #pc$stderr; plot(pc, 5)
#' #pc <- cv.edgwas(x, y, model = "lmer", logrho = FALSE)
#' #pc$stderr; plot(pc, 5)
#' \dontrun{
#' plot(pc, 1)
#' plot(pc, 1, zoom = 10)
#' plot(pc, 2)
#' }
#'
#' @export
#'
cv.edgwas <- function(x, y, rho = NULL, nfolds = 10,
                      type.measure = c("mse", "mae"),
                      nrho = ifelse(is.null(rho), 20, length(rho)), logrho = FALSE,
                      rho.min.ratio = 10e-04,
                      model = c("fgls", "lm", "lmer"),
                      ...
                      ) {

  if (missing(model))
    model = "fgls" #"lm"
  else model = match.arg(model)

  if (!is.null(rho) && length(rho) < 2)
    stop("Need more than one value of rho for cv.edgwas")

  if (missing(type.measure))
    type.measure = "mse"
  else type.measure = match.arg(type.measure)

  edgwas.call <- match.call(expand.dots = TRUE)
  edgwas.call[[1]] <- as.name("edgwas")
  edgwas.object <- edgwas(x, y, rho, nrho, logrho, rho.min.ratio, model)
  edgwas.object$call <- edgwas.call

  if (nfolds < 3)
    stop("nfolds must be bigger than 3; nfolds=10 recommended")

  rho <- edgwas.object$rho
  nrho <- length(rho)
  model <- edgwas.object$model
  PS <- edgwas.object$PS
  P <- edgwas.object$P
  Sigma <- edgwas.object$Sigma
  A <- edgwas.object$A

  foldid <- sample(rep(seq(nfolds), length = nrow(y)))
  outlist = vector(mode = "list", length = nfolds)
  for (i in seq(nfolds)) {
    fold <- foldid == i

    yTrain <- y[!fold, ]
    xTrain <- PS[!fold, ]

    outlist[[i]] <- edgwas(x = xTrain, y = yTrain, rho, nrho, logrho, rho.min.ratio, model)
  }

  cvstuff <- cvcompute(outlist, rho = rho, PS = PS, y = y, nfolds = nfolds,
                       P = P, A = A, Sigma = Sigma, type.measure = type.measure,
                       logrho = logrho, model = model,
                       rho.min.ratio = rho.min.ratio,
                       nrho = nrho, foldid = foldid) #,W = W)
  cvm <- cvstuff$cvm
  cvsd <- cvstuff$cvsd
  cvname <- names(cvstuff$type.measure)

  stderr <- cvstuff$stderr

  whichRho <- which.min(cvm)
  rhoMin <- rho[whichRho]
  idx <- max(which(rev(cvm[seq(whichRho)]) < cvm[whichRho] + cvsd[whichRho]))
  rho1se <- rev(rho[seq(whichRho)])[idx]
  rhoMinStd <- rho[which.min(stderr)]

  out <- list(rho = rho, cvm = cvm, cvsd = cvsd,
              cvup = cvm + cvsd,
              cvlo = cvm - cvsd,
              name = cvname,
              rho.min = rhoMin,
              rho.1se = rho1se,
              stderr = stderr, rhoMinStd = rhoMinStd,
              #lmstderr = cvstuff$lmstderr,
              #lmcvm = cvstuff$lmcvm, lmcvsd = cvstuff$lmcvsd,
              edgwas.fit = edgwas.object)
  class(out) <- "cv.edgwas"
  out
}


#' Internal EdGwas functions.
#'
#' @details These are not intended for use by users but may of interest to developers. cvcompute does cross-validation.
#'
#' @keywords internal
#'
# Cross-validation
cvcompute <- function(outlist, rho, PS, y, nfolds, P, A, Sigma,
                      type.measure, model,
                      logrho, rho.min.ratio, W,
                      nrho, foldid) {

  cvraw <- vector(mode = "list", length = nrho)
  cvraw <- lapply(cvraw, FUN = function(l) matrix(NA, nrow(y), ncol(y)))
  cvmFold <- vector(mode = "list", length = nrho)
  cvmFold <- lapply(cvmFold, FUN = function(l) matrix(NA, nfolds, ncol(y)))
  #lmcvraw <- matrix(NA, nrow(y), ncol(y))
  #lmcvmFold <- matrix(NA, nfolds, ncol(y))


  stderrList <- vector(mode = "list", length = nrho)
  stderrList <- lapply(stderrList, function(j) vector(mode = "list", length = nfolds))
  stderrListAlpha <- vector(mode = "list", length = nrho)
  stderrListAlpha <- lapply(stderrListAlpha, function(j) matrix(NA, nfolds, ncol(y)))
  stderrListBeta <- vector(mode = "list", length = nrho)
  stderrListBeta <- lapply(stderrListBeta, function(j) matrix(NA, nfolds, ncol(y)))
  #lmstderrList <- vector(mode = "list", length = nfolds)

  for (i in 1:nfolds) {

    fold <- foldid == i

    allPreds <- predict(outlist[[i]], newPS = PS[fold, ], type = "link")
    predsList <- allPreds$nfit

    #lmPreds <- allPreds$nlmfit
    #lmcvraw[fold, ] <- switch(type.measure,
    #                          mse = (lmPreds - y[fold, ])^2,
    #                          mae = abs(lmPreds - y[fold, ]))
    #lmcvmFold[i,] <- apply(lmcvraw[fold, ], 2, mean, na.rm = TRUE)
    #lmstderrList[[i]] <- sapply(outlist[[i]]$lmfit, coef)

    for (j in seq(nrho)) {

      cvraw[[j]][fold, ] <- switch(type.measure,
                                    mse = (predsList[[j]] - y[fold, ])^2,
                                    mae = abs(predsList[[j]] - y[fold, ]))

      #############################################
      #                    LM                     #
      #############################################
      if (model == "lm") {
        stderrList[[j]][[i]] <- c(stderrList[[j]][[i]],
                            outlist[[i]]$edgwas.fit$alpha,
                            outlist[[i]]$edgwas.fit$beta)

        #############################################
        #                   FGLS                    #
        #############################################
      } else if (model == "fgls") {
        stderrListAlpha[[j]][i, ] <- outlist[[i]]$alpha[, j]
        stderrListBeta[[j]][i, ] <- outlist[[i]]$beta[, j]

        #############################################
        #                   LMER                    #
        #############################################
      } else if (model == "lmer") {
        clu <- outlist[[i]]$clusters[[j]]

        for (m in seq(clu$no)) {
          csize <- clu$csize[m]
          members <- which(clu$membership == m)
          if (class(outlist[[i]]$summary[[j]][[m]]) == "lm") {
            stderrList[[j]][[i]] <- c(stderrList[[j]][[i]],
                             coef(outlist[[i]]$summary[[j]][[m]]))
          } else {
            stderrList[[j]][[i]] <- c(stderrList[[j]][[i]],
                             lme4::fixef(outlist[[i]]$summary[[j]][[m]]))
          }
        }
      }


      if(FALSE) {
        l <- 10 #1#
        yScale <- apply(y, 2, scale) # y[fold, l]
        ytest <- yScale[fold, l]
        ps0 <- PS[!fold, l]
        fit0 <- lm(yScale[!fold, l] ~ ps0)
        pred0 <- predict(fit0, newdata = data.frame(ps0 = PS[fold, l]))$nfit
        plot(predsList[[j]][,l], ylim = range(pred0, predsList[[j]][,l], ytest)); points(pred0, col = 3); points(ytest, col = 2)
        mean((predsList[[j]][,l] - ytest)^2); mean((pred0 - ytest)^2)
        mean(predsList[[j]][,l]); mean(pred0); mean(ytest)
        sd(predsList[[j]][,l]); sd(pred0); sd(ytest)
      }
        #
      cvmFold[[j]][i,] <- apply(cvraw[[j]][fold, ], 2, mean, na.rm = TRUE)
    }
  }

  N <- nrow(y)
  q <- ncol(y)

  cvm <- sapply(cvraw, mean, na.rm = TRUE)
  cvsd <- sqrt(sapply(seq_along(cvmFold), FUN = function(j) sum((cvmFold[[j]] - cvm[j])^2, na.rm = TRUE))/(q*N-1))

  #lmcvm <- mean(lmcvraw, na.rm = TRUE)
  #lmcvsd <- sqrt(sum((lmcvmFold - lmcvm)^2, na.rm = TRUE))/(q*N-1)
  #lmstderr <- sd(unlist(lmstderrList))

  if (model == "fgls") {
    stderrA <- colMeans(sapply(stderrListAlpha, function(a) apply(a, 2, sd)))
    stderrB <- colMeans(sapply(stderrListBeta, function(a) apply(a, 2, sd)))
    stderr <- stderrB #apply(cbind(stderrA, stderrB), 1, mean)
  } else {
    stderr <- sapply(stderrList, function(x) sd(unlist(x)))
  }

  names(type.measure) <- type.measure

  list(cvm = cvm, cvsd = cvsd, type.measure = type.measure,
       #lmstderr = lmstderr, lmcvm = lmcvm, lmcvsd = lmcvsd,
       stderr = stderr)

}
