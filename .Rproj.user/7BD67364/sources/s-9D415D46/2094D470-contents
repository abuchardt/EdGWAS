#' Cluster multiple traits via PRS
#'
#' This function clusters traits that share some genetic component via polygenic risk scores (PRSs).
#'
#' It fits a sparse precision matrix via graphical lasso. The regularisation path is computed for lasso penalty at a grid of values for the regularisation parameter rho.
#'
#' @param x input matrix, of dimension nobs x nvars; each row is an observation vector. Can be in sparse matrix format.
#' @param y response matrix, of dimension nobs x nouts. Quantitative for family="gaussian". For family="binomial" should be either a factor with two levels, or a two-column matrix of counts or proportions (the second column is treated as the target class; for a factor, the last level in alphabetical order is the target class). For "binomial" if y is presented as a vector, it will be coerced into a factor.
#' @param rho (Non-negative) regularisation parameter for lasso passed to glasso. rho=0 means no regularisation. Can be a scalar (usual) or a symmetric nouts by nouts matrix, or a vector of length nouts. In the latter case, the penalty matrix has jkth element sqrt(rho[j]*rho[k]).
#'
#' @importFrom stats cor cutree dist hclust
#'
#' @import MESS
#' @import glasso
#'
#' @return Cluster associations. \item{clust}{returns a vector with group memberships}
#'
#'
#' @examples
#' # Gaussian
#' N <- 1000
#' q <- 10
#' p <- 10000
#' set.seed(1)
#' X <- matrix(sample(0:2, N*p, replace=TRUE), nrow=N, ncol=p)
#' B <- matrix(0, nrow = p, ncol = q)
#' B[1:2, 1:2] <- 2
#' B[3:4, 3:4] <- 2
#' Y <- X %*% B + matrix(rnorm(N*q), nrow = N, ncol = q)
#' ###
#' pc <- edgwas(x = X, y = Y, rho = 0.8)
#'
#' @export edgwas
#'

edgwas <- function(x, y, rho) {
  #family <- match.arg(family)

  x <- as.matrix(x)
  y <- as.matrix(y)

  np <- dim(x)
  if (is.null(np) | (np[2] <= 1))
    stop("x should be a matrix with 2 or more columns")
  nobs <- as.integer(np[1])
  nvars <- as.integer(np[2])
  dimy <- dim(y)
  nrowy <- ifelse(is.null(dimy), length(y), dimy[1])
  nouts <- ifelse(is.null(dimy), 1, dimy[2])
  if (nrowy != nobs)
    stop(paste("number of observations in y (", nrowy, ") not equal to the number of rows of x (",
               nobs, ")", sep = ""))
  vnames <- colnames(x)
  if (is.null(vnames))
    vnames <- paste("V", seq(nvars), sep = "")
  if (!is.matrix(rho) & length(rho) != 1 & length(rho) != nouts) {
    stop("Wrong number of elements in rho")
  }

  #####################
  # STEP 1
  #####################
  # Compute q simple GWASs
  gwasResults <- lapply(1:nouts, FUN = function(k) MESS::mfastLmCpp(y = y[,k], x = x)$coefficients)
  # Save all pxq regression coefficients
  betaHatMat <- do.call(cbind, gwasResults)

  # Compute Nxq PRSs
  PRS <- mapply(1:nouts, FUN = function(k) x %*% betaHatMat[,k])

  ####################
  # STEP 2
  ####################
  # Covariance matrix (qxq) of PRSs
  SigmaPRS <- cor(PRS) # cov(PRS) #

  # Graphical lasso
  # Estimates a sparse inverse covariance matrix using a lasso (L1) penalty
  glPRS <- glasso::glasso(s = SigmaPRS, rho = rho)

  precMat <- glPRS$wi

  # Compute binary distance (aka asymmetric binary):
  # The vectors are regarded as binary bits, so non-zero elements
  # are ‘on’ and zero elements are ‘off’. The distance is the
  # proportion of bits in which only one is on amongst those in
  # which at least one is on.
  d <- dist(glPRS$wi, method = "binary", diag = TRUE, upper = TRUE)

  # Hierarchical cluster analysis via the single linkage method
  # (which is closely related to the minimal spanning tree and
  # adopts a ‘friends of friends’ clustering strategy).
  hc <- hclust(d, method="single")

  # Save vector of cluster associations
  outcl <- cutree(hc, h=min(hc$height))

  # Return
  fit <- list(clust = outcl, dist = d, precMat = precMat)
  class(fit) <- "edgwas"
  fit
}

#' Cross-validation for EdGwas
#'
#' Does k-fold cross-validation for glmnet, produces a plot, and returns a value for rho.
#'
#' @param x input matrix, of dimension nobs x nvars; each row is an observation vector. Can be in sparse matrix format.
#' @param y response matrix, of dimension nobs x nouts. Quantitative for family="gaussian". For family="binomial" should be either a factor with two levels, or a two-column matrix of counts or proportions (the second column is treated as the target class; for a factor, the last level in alphabetical order is the target class). For "binomial" if y is presented as a vector, it will be coerced into a factor.
#' @param rho (Non-negative) optional user-supplied rho sequence; default is NULL, and EdGwas chooses its own sequence.
#' @param nfolds number of folds - default is 10. Although nfolds can be as large as the sample size (leave-one-out CV), it is not recommended for large datasets. Smallest value allowable is nfolds=3.
#' @param type.measure loss to use for cross-validation. Currently one option; the default is type.measure="rand", which uses the rand index.
#'
#' @importFrom stats cor cutree dist hclust
#'
#' @import MESS
#' @import glasso
#'
#' @return Cluster associations. \item{clust}{returns a vector with group memberships}
#' @export cv.edgwas
#'
cv.edgwas <- function(x, y, rho = NULL, nfolds = 10, type.measure = "rand") {

}
